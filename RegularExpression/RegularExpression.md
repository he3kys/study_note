[toc]

# 基本语法

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
例如：

- runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。

- runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。

- colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。


### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：


```c {.line-numbers}
\cx
匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。

\f
匹配一个换页符。等价于 \x0c 和 \cL。

\n
匹配一个换行符。等价于 \x0a 和 \cJ。

\r
匹配一个回车符。等价于 \x0d 和 \cM。

\s
匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。

\S
匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。

\t
匹配一个制表符。等价于 \x09 和 \cI。

\v
匹配一个垂直制表符。等价于 \x0b 和 \cK。

\b	
匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。

\B	
匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。

\d	
匹配一个数字字符。等价于[0-9]。

\D	
匹配一个非数字字符。等价于[^0-9]。

\w	
匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。

\W	
匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
```



### 特殊字符


```c {.line-numbers}
所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 \: runo\*ob 匹配 runo*ob。

许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：
```


```c {.line-numbers}
$
匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。

( )
标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)

*
匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*

+
匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+

.
匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 

[
标记一个中括号表达式的开始。要匹配 [，请使用 \[。

?
匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。

\
将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\' 匹配 "\"，而 '\(' 则匹配 "("。

^
匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。

{
标记限定符表达式的开始。要匹配 {，请使用 \{。

|
指明两项之间的一个选择。要匹配 |，请使用 \|

```

### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。

正则表达式的限定符有：


```c {.line-numbers}
*
匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。

+
匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。

?
匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。
当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。

{n}
n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。

{n,}
n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。

{n,m}
m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。


```


# 文本编辑器中正则表达式

常用编辑器如notepad++，vscode都支持正则表达式搜索

## 关系或

- 关系或：用符号"|"，注意符号"|"两边不能加空格，除非需要搜索的关键词就带有空格

如下是一段运行log：

```c {.line-numbers}
09-10 16:49:01.847 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：A料盘到位，准备取料
09-10 16:49:01.847 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：A料盘：位置1，准备取料
09-10 16:49:02.187 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：发送取料命令
09-10 16:49:02.307 [Station2 Coordinator] INFO  DefaultLog - 模组2_2：离开治具2_2
09-10 16:49:02.678 [Station2 Coordinator] INFO  DefaultLog - 治具2_2：上料完成，左穴有料，右穴有料，发送开始测试命令
09-10 16:49:02.893 [Unloader Coordinator] INFO  DefaultLog - write Reg_Downstream_Empty_Line_Ready: 1
09-10 16:49:03.217 [Station2 Coordinator] INFO  DefaultLog - 模组2_2：D料盘：位置11，准备取料
09-10 16:49:03.567 [Station2 Coordinator] INFO  DefaultLog - 模组2_2：发送取料命令
09-10 16:49:03.872 [Station2 Coordinator] INFO  DefaultLog - write Reg_Upstream_Empty_Tray_Ready: 0
09-10 16:49:04.357 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：取料结果1，吸嘴1上有料，吸嘴2上有料
09-10 16:49:04.707 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：载板上无料，吸嘴上有料，发送上料命令
09-10 16:49:05.078 [Station2 Coordinator] INFO  DefaultLog - 治具2_2：载板2测试完成，关闭真空吸，等待下料
```

如果想从中筛选出包含“模组2_1”或者“模组2_2”的日志，正则表达式的写法如下：

```c {.line-numbers}
模组2_1|模组2_2
```


## 关系与

- 关系与：用两个符号".*"一起表示

如下是一段运行log：

```c {.line-numbers}
09-10 16:49:01.847 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：A料盘到位，准备取料
09-10 16:49:01.847 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：A料盘：位置1，准备取料
09-10 16:49:02.187 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：发送取料命令
09-10 16:49:02.307 [Station2 Coordinator] INFO  DefaultLog - 模组2_2：离开治具2_2
09-10 16:49:02.678 [Station2 Coordinator] INFO  DefaultLog - 治具2_2：上料完成，左穴有料，右穴有料，发送开始测试命令
09-10 16:49:02.893 [Unloader Coordinator] INFO  DefaultLog - write Reg_Downstream_Empty_Line_Ready: 1
09-10 16:49:03.217 [Station2 Coordinator] INFO  DefaultLog - 模组2_2：D料盘：位置11，准备取料
09-10 16:49:03.567 [Station2 Coordinator] INFO  DefaultLog - 模组2_2：发送取料命令
09-10 16:49:03.872 [Station2 Coordinator] INFO  DefaultLog - write Reg_Upstream_Empty_Tray_Ready: 0
09-10 16:49:04.357 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：取料结果1，吸嘴1上有料，吸嘴2上有料
09-10 16:49:04.707 [Station2 Coordinator] INFO  DefaultLog - 模组2_1：载板上无料，吸嘴上有料，发送上料命令
09-10 16:49:05.078 [Station2 Coordinator] INFO  DefaultLog - 治具2_2：载板2测试完成，关闭真空吸，等待下料
```

如果想从中筛选出包含“模组2”和“A料盘”的日志，正则表达式的写法如下：

```c {.line-numbers}
模组2.*A料盘
```

语法解析：
> 其中符号"."表示任意字符，符号"*"表示匹配0次或者多次，两者结合起来就表示多个任意字符，也就是关键词“模组2”和关键词“A料盘”之间有任意多个字符

*注：此种搜索方式只在段内匹配*

## 搜索指定的一个或者多个任意文字

如下是一套试题中的一部分：

``` {.line-numbers}
软件设计中模块划分应遵循的准则是（B）.
已知如下代码，选项中函数调用语句错误的是（D）.
以下哪个选项可以组成一个正常通信的I2C报文（D）.
以下关于I2C的描述正确的是（ABC）.
```
现在要将括号中的答案全部删除，可以采用正则表达式替换的方式，搜索内容为：

```c {.line-numbers}
（.{1,4}）.
```

将其替换为：

```c {.line-numbers}
（ ）.
```

即可删除整套试题中所有选择题的答案

语法解析：
> 符号“.”表示任意字符，表达式“{1,4}”匹配1到4次，两者结合起来表示匹配1-4个任意字符，也就是关键词“（”和关键词“）.”之间有1-4个任意字符。

## 批量删除HTML注释

匹配HTML单行注释：

```html {.line-numbers}
<!--(.*?)-->
```



匹配HTML多行注释：

```html {.line-numbers}
<!--([\s\S|\r]*?)-->
或者
<!--([\w\W]*?)-->
```


# python正则表达式

### 匹配电话号码

```python {.line-numbers}
import re

phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
mo = phoneNumRegex.search('My number is 415-555-4242.')
print('Phone number found: ' + mo.group())
```

**流程:**

1. 导入re模块

1. 新建re对象：phoneNumRegex

1. 调用re.compile将正则表达式编译为re对象

1. 调用serch函数在指定字符串中进行正则匹配，并将结果返回给Match对象

1. 调用Match对象的group函数，将完整的匹配内容取出来

**相关知识：**

1. 在字符串前面增加一个字符r表示当前字符串是原始字符串，里面所有的内容都按字符解析


